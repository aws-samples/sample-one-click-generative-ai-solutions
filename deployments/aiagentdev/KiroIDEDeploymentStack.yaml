AWSTemplateFormatVersion: '2010-09-09'
Description: Kiro IDE Deployment - Amazon Linux 2023 x86_64 with ALB and CloudFront

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Kiro IDE Deployment Parameters"
        Parameters:
          - UserEmail
          - UserFullName
          - InstanceType
          - InstanceVolumeSize
          - HomeFolder
          - RepoUrl

Parameters:
  UserEmail:
    Type: String
    Description: User email address (used for notifications and system configuration)
    AllowedPattern: '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    ConstraintDescription: Must be a valid email address
  UserFullName:
    Type: String
    Description: Full name for system configuration
    Default: Kiro IDE Developer
  InstanceType:
    Type: String
    Default: t3.medium
    Description: EC2 instance type (x86_64 architecture required for Kiro IDE)
  InstanceVolumeSize:
    Type: Number
    Default: 40
    Description: EBS volume size in GB
  HomeFolder:
    Type: String
    Default: /workspace
    Description: User home directory path
  RepoUrl:
    Type: String
    Default: ''
    Description: Optional Git repository to clone for development

Mappings:
  CloudFrontPrefixListID:
    ap-northeast-1:
      PrefixList: pl-58a04531
    ap-northeast-3:
      PrefixList: pl-31a14458
    us-east-1:
      PrefixList: pl-3b927c52
    us-west-2:
      PrefixList: pl-82a045eb

Resources:
  # VPC and Networking
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.1.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-VPC'

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-IGW'

  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref VPC

  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: 10.1.1.0/24
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Public-Subnet-1'

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: 10.1.2.0/24
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Public-Subnet-2'

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Public-Routes'

  DefaultPublicRoute:
    Type: AWS::EC2::Route
    DependsOn: InternetGatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet1

  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet2

  # Security Groups
  ALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${AWS::StackName}-ALB-SG'
      GroupDescription: Security group for ALB
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          SourcePrefixListId: !FindInMap [CloudFrontPrefixListID, !Ref 'AWS::Region', PrefixList]
          Description: HTTP from CloudFront only
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ALB-SG'

  InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${AWS::StackName}-Instance-SG'
      GroupDescription: Security group for Kiro IDE instance
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 8443
          ToPort: 8443
          SourceSecurityGroupId: !Ref ALBSecurityGroup
          Description: NICE DCV access from ALB only
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Instance-SG'

  ALBToInstanceEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref ALBSecurityGroup
      IpProtocol: tcp
      FromPort: 8443
      ToPort: 8443
      DestinationSecurityGroupId: !Ref InstanceSecurityGroup
      Description: Allow ALB to DCV

  # WaitCondition to delay CloudFormation completion until DCV is ready after reboot
  DCVReadyHandle:
    Type: AWS::CloudFormation::WaitConditionHandle

  DCVReadyCondition:
    Type: AWS::CloudFormation::WaitCondition
    DependsOn: RunSSMDoc
    Properties:
      Handle: !Ref DCVReadyHandle
      Timeout: '900'
      Count: 1

  # Lambda to poll ALB target health and signal WaitCondition
  HealthCheckLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.handler
      Timeout: 600
      Role: !GetAtt HealthCheckLambdaRole.Arn
      Code:
        ZipFile: |
          import boto3
          import urllib.request
          import json
          import time
          
          def handler(event, context):
              if event['RequestType'] == 'Delete':
                  send_response(event, 'SUCCESS')
                  return
              
              elbv2 = boto3.client('elbv2')
              target_group_arn = event['ResourceProperties']['TargetGroupArn']
              wait_url = event['ResourceProperties']['WaitConditionUrl']
              
              # Poll for up to 8 minutes
              for i in range(96):
                  try:
                      resp = elbv2.describe_target_health(TargetGroupArn=target_group_arn)
                      for target in resp['TargetHealthDescriptions']:
                          if target['TargetHealth']['State'] == 'healthy':
                              signal_wait_condition(wait_url, 'SUCCESS', 'DCV is healthy')
                              send_response(event, 'SUCCESS')
                              return
                  except Exception as e:
                      print(f"Error checking health: {e}")
                  time.sleep(5)
              
              signal_wait_condition(wait_url, 'FAILURE', 'DCV health check timeout')
              send_response(event, 'FAILED', 'Health check timeout')
          
          def signal_wait_condition(url, status, reason):
              data = json.dumps({'Status': status, 'Reason': reason, 'UniqueId': 'dcv', 'Data': reason}).encode()
              req = urllib.request.Request(url, data=data, method='PUT', headers={'Content-Type': ''})
              urllib.request.urlopen(req)
          
          def send_response(event, status, reason=''):
              data = json.dumps({'Status': status, 'Reason': reason or status, 'PhysicalResourceId': 'health-check', 'StackId': event['StackId'], 'RequestId': event['RequestId'], 'LogicalResourceId': event['LogicalResourceId']}).encode()
              req = urllib.request.Request(event['ResponseURL'], data=data, method='PUT', headers={'Content-Type': ''})
              urllib.request.urlopen(req)

  HealthCheckLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ELBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: elasticloadbalancing:DescribeTargetHealth
                Resource: '*'

  HealthCheckTrigger:
    Type: Custom::HealthCheck
    DependsOn: RunSSMDoc
    Properties:
      ServiceToken: !GetAtt HealthCheckLambda.Arn
      TargetGroupArn: !Ref ALBTargetGroup
      WaitConditionUrl: !Ref DCVReadyHandle

  # IAM Role for EC2 Instance
  InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
      Policies:
        - PolicyName: DCVLicenseAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: s3:GetObject
                Resource: !Sub 'arn:${AWS::Partition}:s3:::dcv-license.${AWS::Region}/*'

  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref InstanceRole

  # Secrets Manager for User Credentials
  UserCredentials:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub 'KiroIDE-${AWS::StackName}'
      GenerateSecretString:
        PasswordLength: 16
        ExcludePunctuation: true

  # Generate username from email
  UsernameGenerator:
    Type: Custom::UsernameGenerator
    Properties:
      ServiceToken: !GetAtt UsernameGeneratorLambda.Arn
      Email: !Ref UserEmail

  UsernameGeneratorLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.handler
      Timeout: 10
      Role: !GetAtt UsernameGeneratorRole.Arn
      Code:
        ZipFile: |
          import cfnresponse
          import re
          import hashlib
          def handler(event, context):
              if event['RequestType'] == 'Delete':
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                  return
              try:
                  email = event['ResourceProperties']['Email']
                  raw = email.split('@')[0]
                  username = re.sub(r'[.+]', '_', raw.lower())
                  username = re.sub(r'[^a-z0-9_-]', '', username)
                  username = re.sub(r'^[-0-9]+', '', username)[:32].rstrip('-_')
                  if not username or not username[0].isalpha():
                      username = 'user' + hashlib.md5(raw.encode()).hexdigest()[:8]
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {'Username': username})
              except Exception as e:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, str(e))

  UsernameGeneratorRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # SSM Document for Kiro IDE Installation
  KiroIDESSMDoc:
    Type: AWS::SSM::Document
    Properties:
      DocumentType: Command
      Content:
        schemaVersion: '2.2'
        parameters:
          UserPassword:
            type: String
          Username:
            type: String
          UserFullName:
            type: String
          HomeFolder:
            type: String
          UserEmail:
            type: String
          RepoUrl:
            type: String
        mainSteps:
          - name: InstallDependencies
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  # Update system packages
                  dnf update -y -q
                  # Install fundamental packages (git, jq not pre-installed on AL2023)
                  dnf install -y git jq

          - name: SetupUser
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  #!/bin/bash
                  set -e
                  
                  USERNAME="{{ Username }}"
                  
                  # Create user if not exists, update password if exists
                  if id "$USERNAME" &>/dev/null; then
                    echo "User $USERNAME already exists, updating password"
                  else
                    useradd -m -s /bin/bash "$USERNAME"
                  fi
                  echo "$USERNAME:{{ UserPassword }}" | chpasswd
                  usermod -aG wheel "$USERNAME"
                  
                  # Create home folder
                  mkdir -p "{{ HomeFolder }}"
                  chown "$USERNAME:$USERNAME" "{{ HomeFolder }}"
                  
                  echo "$USERNAME" > /etc/kiro-username

          - name: InstallDesktopEnvironment
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  # Install GNOME desktop
                  dnf groupinstall -y "Desktop"
                  dnf upgrade -y
                  
                  # Set graphical target
                  systemctl set-default graphical.target
                  
                  # Skip GNOME initial setup wizard
                  USERNAME=$(cat /etc/kiro-username)
                  mkdir -p "/home/$USERNAME/.config"
                  touch "/home/$USERNAME/.config/gnome-initial-setup-done"
                  chown -R "$USERNAME:$USERNAME" "/home/$USERNAME/.config"

          - name: InstallNICEDCV
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  # Download and install NICE DCV
                  rpm --import https://d1uj6qtbmh3dt5.cloudfront.net/NICE-GPG-KEY
                  cd /tmp
                  wget -q https://d1uj6qtbmh3dt5.cloudfront.net/nice-dcv-amzn2023-x86_64.tgz
                  tar -xzf nice-dcv-amzn2023-x86_64.tgz
                  cd nice-dcv-*-amzn2023-x86_64
                  dnf install -y nice-dcv-server-*.amzn2023.x86_64.rpm nice-dcv-web-viewer-*.amzn2023.x86_64.rpm
                  cd /tmp
                  rm -rf nice-dcv-*
                  
                  # Install XDummy driver for console sessions
                  dnf install -y xorg-x11-drv-dummy
                  
                  # Configure XDummy
                  mkdir -p /etc/X11
                  cat > /etc/X11/xorg.conf << 'XORGEOF'
                  Section "Device"
                      Identifier "DummyDevice"
                      Driver "dummy"
                      Option "UseEDID" "false"
                      VideoRam 512000
                  EndSection
                  
                  Section "Monitor"
                      Identifier "DummyMonitor"
                      HorizSync   5.0 - 1000.0
                      VertRefresh 5.0 - 200.0
                      Option "ReducedBlanking"
                  EndSection
                  
                  Section "Screen"
                      Identifier "DummyScreen"
                      Device "DummyDevice"
                      Monitor "DummyMonitor"
                      DefaultDepth 24
                      SubSection "Display"
                          Viewport 0 0
                          Depth 24
                          Virtual 4096 2160
                      EndSubSection
                  EndSection
                  XORGEOF
                  
                  # Configure DCV for automatic console session
                  USERNAME=$(cat /etc/kiro-username)
                  mkdir -p /etc/dcv
                  cat > /etc/dcv/dcv.conf << DCVEOF
                  [license]
                  [log]
                  level=info
                  [session-management]
                  create-session=true
                  [session-management/defaults]
                  [session-management/automatic-console-session]
                  owner="$USERNAME"
                  storage-root="%home%"
                  [display]
                  [connectivity]
                  enable-quic-frontend=true
                  web-url-path="/dcv"
                  [security]
                  authentication=system
                  DCVEOF
                  
                  # Set user password for DCV authentication (required for system auth)
                  echo "$USERNAME:{{ UserPassword }}" | chpasswd
                  
                  # Enable and start DCV
                  systemctl enable dcvserver
                  systemctl start dcvserver

          - name: InstallBrowser
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  # Install xdg-utils and configure Firefox as default browser
                  dnf install -y xdg-utils
                  USERNAME=$(cat /etc/kiro-username)
                  sudo -u "$USERNAME" xdg-settings set default-web-browser firefox.desktop || true
                  echo "export BROWSER=firefox" >> "/home/$USERNAME/.bashrc"
                  chown "$USERNAME:$USERNAME" "/home/$USERNAME/.bashrc"

          - name: InstallKiroIDE
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  # Install Kiro IDE from official release
                  USERNAME=$(cat /etc/kiro-username)
                  
                  # Get latest version and download tar.gz
                  cd /tmp
                  VERSION=$(curl -s https://prod.download.desktop.kiro.dev/stable/metadata-linux-x64-stable.json | jq -r .currentRelease)
                  curl -o kiro-ide.tar.gz "https://prod.download.desktop.kiro.dev/releases/stable/linux-x64/signed/$VERSION/tar/kiro-ide-$VERSION-stable-linux-x64.tar.gz"
                  
                  # Install to /opt
                  mkdir -p /opt/kiro-ide
                  tar -xzf kiro-ide.tar.gz -C /opt/kiro-ide --strip-components=1
                  rm kiro-ide.tar.gz
                  chown -R "$USERNAME:$USERNAME" /opt/kiro-ide
                  
                  # Create symlink
                  ln -sf /opt/kiro-ide/kiro /usr/local/bin/kiro-ide
                  
                  # Create desktop entry
                  cat > /usr/share/applications/kiro-ide.desktop << 'KIROEOF'
                  [Desktop Entry]
                  Version=1.0
                  Type=Application
                  Name=Kiro IDE
                  Icon=/opt/kiro-ide/resources/app/resources/linux/code.png
                  Exec=/opt/kiro-ide/kiro
                  Terminal=false
                  Categories=Development;IDE;
                  KIROEOF
                  chmod 644 /usr/share/applications/kiro-ide.desktop
                  
                  # Create desktop shortcut for user
                  mkdir -p "/home/$USERNAME/Desktop"
                  cp /usr/share/applications/kiro-ide.desktop "/home/$USERNAME/Desktop/"
                  chmod +x "/home/$USERNAME/Desktop/kiro-ide.desktop"
                  chown -R "$USERNAME:$USERNAME" "/home/$USERNAME/Desktop"

          - name: RebuildSQLite
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  # Rebuild SQLite module for AL2023 GLIBC 2.34 compatibility
                  dnf install -y nodejs npm gcc-c++ make sqlite-devel
                  cd /tmp
                  npm install --build-from-source @vscode/sqlite3
                  if [ -f /tmp/node_modules/@vscode/sqlite3/build/Release/vscode-sqlite3.node ]; then
                      cp /opt/kiro-ide/resources/app/node_modules/@vscode/sqlite3/build/Release/vscode-sqlite3.node \
                         /opt/kiro-ide/resources/app/node_modules/@vscode/sqlite3/build/Release/vscode-sqlite3.node.original
                      cp /tmp/node_modules/@vscode/sqlite3/build/Release/vscode-sqlite3.node \
                         /opt/kiro-ide/resources/app/node_modules/@vscode/sqlite3/build/Release/vscode-sqlite3.node
                      USERNAME=$(cat /etc/kiro-username)
                      chown "$USERNAME:$USERNAME" /opt/kiro-ide/resources/app/node_modules/@vscode/sqlite3/build/Release/vscode-sqlite3.node
                  fi
                  rm -rf /tmp/node_modules

          - name: ConfigureGitAndRepo
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  USERNAME=$(cat /etc/kiro-username)
                  
                  # Configure git
                  sudo -u "$USERNAME" git config --global user.email "{{ UserEmail }}"
                  sudo -u "$USERNAME" git config --global user.name "{{ UserFullName }}"
                  
                  # Clone repository if provided and directory doesn't exist
                  if [ -n "{{ RepoUrl }}" ] && [ ! -d "{{ HomeFolder }}/project" ]; then
                    cd "{{ HomeFolder }}"
                    sudo -u "$USERNAME" git clone "{{ RepoUrl }}" project
                    chown -R "$USERNAME:$USERNAME" "{{ HomeFolder }}/project"
                  fi

          - name: FinalizeSetup
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  # Reboot to ensure all services start properly
                  reboot

  # EC2 Instance
  Instance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: '{{resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64}}'
      InstanceType: !Ref InstanceType
      IamInstanceProfile: !Ref InstanceProfile
      SecurityGroupIds:
        - !Ref InstanceSecurityGroup
      SubnetId: !Ref PublicSubnet1
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeSize: !Ref InstanceVolumeSize
            VolumeType: gp3
            DeleteOnTermination: true
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          echo "Bootstrap complete - setup handled by SSM document"
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-KiroIDE-Instance'

  # ALB for DCV access
  ALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub '${AWS::StackName}-ALB'
      Scheme: internet-facing
      Type: application
      Subnets:
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      SecurityGroups:
        - !Ref ALBSecurityGroup

  ALBTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub '${AWS::StackName}-TG-DCV'
      Port: 8443
      Protocol: HTTPS
      TargetType: instance
      VpcId: !Ref VPC
      HealthCheckPath: /
      HealthCheckPort: '8443'
      HealthCheckProtocol: HTTPS
      HealthCheckTimeoutSeconds: 10
      HealthyThresholdCount: 2
      Matcher:
        HttpCode: 200,404
      Targets:
        - Id: !Ref Instance

  ALBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref ALB
      Port: 80
      Protocol: HTTP
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref ALBTargetGroup

  # CloudFront Distribution
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        DefaultCacheBehavior:
          TargetOriginId: !Sub ALB-${AWS::StackName}
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods: [DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT]
          CachedMethods: [GET, HEAD]
          CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad
          OriginRequestPolicyId: 216adef6-5c7f-47e4-b989-5492eafa07d3
        Origins:
          - DomainName: !GetAtt ALB.DNSName
            Id: !Sub ALB-${AWS::StackName}
            CustomOriginConfig:
              OriginProtocolPolicy: http-only
              HTTPPort: 80
              HTTPSPort: 443

  # Custom resource to run SSM document
  RunSSMDoc:
    Type: Custom::RunSSMDoc
    Properties:
      ServiceToken: !GetAtt RunSSMDocLambda.Arn
      InstanceId: !Ref Instance
      DocumentName: !Ref KiroIDESSMDoc
      SecretArn: !Ref UserCredentials
      Username: !GetAtt UsernameGenerator.Username
      UserEmail: !Ref UserEmail
      UserFullName: !Ref UserFullName
      HomeFolder: !Ref HomeFolder
      RepoUrl: !Ref RepoUrl

  RunSSMDocLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      MemorySize: 128
      Timeout: 600
      Architectures: [x86_64]
      Handler: index.lambda_handler
      Role: !GetAtt RunSSMDocLambdaRole.Arn
      Code:
        ZipFile: |
          import cfnresponse
          import boto3
          import json
          
          def lambda_handler(event, context):
              if event['RequestType'] != 'Create':
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                  return
              try:
                  props = event['ResourceProperties']
                  
                  # Retrieve password from Secrets Manager
                  secretsmanager = boto3.client('secretsmanager')
                  secret_arn = props['SecretArn']
                  secret_response = secretsmanager.get_secret_value(SecretId=secret_arn)
                  password = secret_response['SecretString']
                  
                  # Prepare parameters with resolved password
                  params = {k: [v] for k, v in props.items() 
                           if k not in ['ServiceToken', 'InstanceId', 'DocumentName', 'SecretArn']}
                  params['UserPassword'] = [password]
                  
                  response = boto3.client('ssm').send_command(
                      InstanceIds=[props['InstanceId']],
                      DocumentName=props['DocumentName'],
                      Parameters=params)
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, 
                      {'CommandId': response['Command']['CommandId'], 'Password': password})
              except Exception as e:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, str(e))

  RunSSMDocLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SSMAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action: 
                  - ssm:SendCommand
                  - secretsmanager:GetSecretValue
                Resource: '*'

  # SNS Topic for Notifications
  DeploymentNotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: Kiro IDE Deployment Notifications
      TopicName: !Sub 'KiroIDE-Notification-${AWS::StackName}'

  DeploymentNotificationSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Protocol: email
      TopicArn: !Ref DeploymentNotificationTopic
      Endpoint: !Ref UserEmail

  StackStatusRule:
    Type: AWS::Events::Rule
    Properties:
      EventPattern:
        source: ["aws.cloudformation"]
        detail-type: ["CloudFormation Stack Status Change"]
        detail:
          stack-id: [!Ref AWS::StackId]
          status-details:
            status: ["CREATE_COMPLETE", "CREATE_FAILED", "UPDATE_COMPLETE", "UPDATE_FAILED"]
      Targets:
        - Arn: !GetAtt NotificationLambda.Arn
          Id: "StackStatusTarget"

  NotificationLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.handler
      Timeout: 30
      Code:
        ZipFile: !Sub
          - |
            import boto3
            
            sns = boto3.client('sns')
            secretsmanager = boto3.client('secretsmanager')
            
            def handler(event, context):
                try:
                    detail = event['detail']
                    status = detail['status-details']['status']
                    stack_id = detail['stack-id']
                    
                    password = secretsmanager.get_secret_value(SecretId="${UserCredentials}")['SecretString']
                    username = "${Username}"
                    
                    message = "Kiro IDE Deployment " + status + " for ${UserEmail}\n\n"
                    message += "Stack ID: " + stack_id + "\n\n"
                    message += "Access Information:\n"
                    message += "URL: https://${CloudFrontDistribution.DomainName}/dcv\n"
                    message += "Username: " + username + "\n"
                    message += "Password: " + password + "\n\n"
                    message += "Please enter the username and password when prompted to access your Kiro IDE environment."
                    
                    sns.publish(
                        TopicArn='${DeploymentNotificationTopic}',
                        Message=message,
                        Subject='Kiro IDE Deployment ' + status
                    )
                    
                    return {'statusCode': 200}
                except Exception as e:
                    print('Error: ' + str(e))
                    return {'statusCode': 500}
          - Username: !GetAtt UsernameGenerator.Username
      Role: !GetAtt NotificationLambdaRole.Arn

  NotificationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: NotificationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: sns:Publish
                Resource: !Ref DeploymentNotificationTopic
              - Effect: Allow
                Action: secretsmanager:GetSecretValue
                Resource: !Ref UserCredentials

  NotificationLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref NotificationLambda
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt StackStatusRule.Arn

Outputs:
  KiroIDEURL:
    Description: Kiro IDE Access URL via CloudFront
    Value: !Sub 'https://${CloudFrontDistribution.DomainName}/dcv'
  
  Username:
    Description: Username for Kiro IDE login
    Value: !GetAtt UsernameGenerator.Username
  
  Password:
    Description: Password for Kiro IDE login
    Value: !GetAtt RunSSMDoc.Password
  
  InstanceId:
    Description: EC2 Instance ID
    Value: !Ref Instance
