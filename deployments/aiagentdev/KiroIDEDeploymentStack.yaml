AWSTemplateFormatVersion: '2010-09-09'
Description: Kiro IDE Deployment - Ubuntu x86_64

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Kiro IDE Deployment Parameters"
        Parameters:
          - UserEmail
          - UserFullName
          - InstanceType
          - InstanceVolumeSize
          - HomeFolder
          - RepoUrl

Parameters:
  UserEmail:
    Type: String
    Description: User email address (used for notifications and system configuration)
    AllowedPattern: '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    ConstraintDescription: Must be a valid email address
  UserFullName:
    Type: String
    Description: Full name for system configuration
    Default: Kiro IDE Developer
  InstanceType:
    Type: String
    Default: t3.medium
    Description: EC2 instance type (x86_64 architecture required for Kiro IDE)
  InstanceVolumeSize:
    Type: Number
    Default: 40
    Description: EBS volume size in GB
  HomeFolder:
    Type: String
    Default: /workspace
    Description: User home directory path
  RepoUrl:
    Type: String
    Default: ''
    Description: Optional Git repository to clone for development

Mappings:
  AmdImage:
    Ubuntu-24:
      ImageId: '{{resolve:ssm:/aws/service/canonical/ubuntu/server/noble/stable/current/amd64/hvm/ebs-gp3/ami-id}}'
  AWSRegionsPrefixListID:
    us-east-1:
      PrefixList: pl-3b927c52
    us-west-2:
      PrefixList: pl-82a045eb

Resources:
  HasIpRestriction: !Not [!Equals [!Ref AllowedIpV4AddressRanges, '']]

Resources:
  # VPC and Networking
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.1.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-VPC'

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-IGW'

  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref VPC

  PublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: 10.1.1.0/24
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Public-Subnet'

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Public-Routes'

  DefaultPublicRoute:
    Type: AWS::EC2::Route
    DependsOn: InternetGatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet

  # Security Groups
  InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${AWS::StackName}-Instance-SG'
      GroupDescription: Security group for Kiro IDE instance
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 8443
          ToPort: 8443
          SourcePrefixListId: !FindInMap [AWSRegionsPrefixListID, !Ref 'AWS::Region', PrefixList]
          Description: NICE DCV access only via CloudFront
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Instance-SG'

  # IAM Role for EC2 Instance
  InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
      Policies:
        - PolicyName: SecretsManagerAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Ref UserCredentials
        - PolicyName: SSMParameterStoreAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:PutParameter
                Resource: !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/KiroIDE/${AWS::StackName}/Username'

  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref InstanceRole

  # Secrets Manager for User Credentials
  UserCredentials:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub 'KiroIDE-${AWS::StackName}'
      GenerateSecretString:
        PasswordLength: 16
        ExcludePunctuation: true

  # SSM Document for Kiro IDE Installation
  KiroIDESSMDoc:
    Type: AWS::SSM::Document
    Properties:
      DocumentType: Command
      Content:
        schemaVersion: '2.2'
        parameters:
          UserPassword:
            type: String
          UserEmail:
            type: String
          UserFullName:
            type: String
          HomeFolder:
            type: String
          RepoUrl:
            type: String
          StackName:
            type: String
        mainSteps:
          - name: InstallPrerequisites
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  apt-get update
                  apt-get install -y jq unzip
                  curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "/tmp/awscliv2.zip"
                  unzip -q /tmp/awscliv2.zip -d /tmp
                  /tmp/aws/install
                  rm -rf /tmp/awscliv2.zip /tmp/aws

          - name: SetupUser
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  #!/bin/bash
                  set -e
                  
                  # Create user from email
                  RAW_USERNAME=$(echo "{{ UserEmail }}" | cut -d'@' -f1)
                  USERNAME=$(echo "$RAW_USERNAME" | tr '[:upper:]' '[:lower:]' | sed 's/[.+]/_/g' | sed 's/[^a-z0-9_-]//g' | sed 's/^[-0-9]*//' | cut -c1-32 | sed 's/[-_]*$//')
                  if [[ -z "$USERNAME" || ! "$USERNAME" =~ ^[a-z] ]]; then
                    USERNAME="user$(echo "$RAW_USERNAME" | md5sum | cut -c1-8)"
                  fi
                  
                  # Create user if not exists, update password if exists
                  if id "$USERNAME" &>/dev/null; then
                    echo "User $USERNAME already exists, updating password"
                  else
                    useradd -m -s /bin/bash "$USERNAME"
                  fi
                  echo "$USERNAME:{{ UserPassword }}" | chpasswd
                  usermod -aG sudo "$USERNAME"
                  
                  # Create home folder
                  mkdir -p "{{ HomeFolder }}"
                  chown "$USERNAME:$USERNAME" "{{ HomeFolder }}"
                  
                  echo "$USERNAME" > /etc/kiro-username
                  
                  # Store username in SSM Parameter Store for notification
                  aws ssm put-parameter --name "/KiroIDE/{{ StackName }}/Username" --value "$USERNAME" --type String --overwrite

          - name: InstallDesktopEnvironment
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  # Update system
                  apt-get update
                  
                  # Install GNOME desktop minimal
                  DEBIAN_FRONTEND=noninteractive apt-get install -y ubuntu-desktop-minimal
                  
                  # Set graphical target
                  systemctl set-default graphical.target
                  
                  # Skip GNOME initial setup wizard
                  USERNAME=$(cat /etc/kiro-username)
                  mkdir -p "/home/$USERNAME/.config"
                  touch "/home/$USERNAME/.config/gnome-initial-setup-done"
                  chown -R "$USERNAME:$USERNAME" "/home/$USERNAME/.config"
                  
                  # Fix DNS after ubuntu-desktop-minimal installation (LP: #2097769)
                  # Installing desktop switches renderer to NetworkManager but doesn't apply it
                  netplan apply

          - name: InstallNICEDCV
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  # Download and install NICE DCV
                  cd /tmp
                  wget --tries=10 --retry-connrefused --waitretry=5 https://d1uj6qtbmh3dt5.cloudfront.net/nice-dcv-ubuntu2404-x86_64.tgz
                  tar -xzf nice-dcv-ubuntu2404-x86_64.tgz
                  cd nice-dcv-*-ubuntu2404-x86_64
                  apt-get install -y ./nice-dcv-server_*.deb ./nice-dcv-web-viewer_*.deb ./nice-xdcv_*.deb
                  
                  # Add dcv user to video group
                  usermod -aG video dcv
                  
                  # Install XDummy driver for console sessions
                  apt-get install -y xserver-xorg-video-dummy
                  
                  # Configure XDummy
                  mkdir -p /etc/X11
                  cat > /etc/X11/xorg.conf << 'XORGEOF'
                  Section "Device"
                      Identifier "DummyDevice"
                      Driver "dummy"
                      Option "UseEDID" "false"
                      VideoRam 512000
                  EndSection
                  
                  Section "Monitor"
                      Identifier "DummyMonitor"
                      HorizSync   5.0 - 1000.0
                      VertRefresh 5.0 - 200.0
                      Option "ReducedBlanking"
                  EndSection
                  
                  Section "Screen"
                      Identifier "DummyScreen"
                      Device "DummyDevice"
                      Monitor "DummyMonitor"
                      DefaultDepth 24
                      SubSection "Display"
                          Viewport 0 0
                          Depth 24
                          Virtual 4096 2160
                      EndSubSection
                  EndSection
                  XORGEOF
                  
                  # Configure DCV for automatic console session
                  USERNAME=$(cat /etc/kiro-username)
                  mkdir -p /etc/dcv
                  cat > /etc/dcv/dcv.conf << DCVEOF
                  [license]
                  [log]
                  level=info
                  [session-management]
                  create-session=true
                  [session-management/defaults]
                  [session-management/automatic-console-session]
                  owner="$USERNAME"
                  storage-root="%home%"
                  [display]
                  [connectivity]
                  enable-quic-frontend=true
                  web-url-path="/dcv"
                  [security]
                  authentication=system
                  DCVEOF
                  
                  # Enable and start DCV
                  systemctl enable dcvserver
                  systemctl start dcvserver

          - name: InstallChrome
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  # Install Google Chrome (official method)
                  cd /tmp
                  wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
                  apt-get install -y ./google-chrome-stable_current_amd64.deb

          - name: InstallKiroIDE
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  # Install Kiro IDE from official release
                  USERNAME=$(cat /etc/kiro-username)
                  
                  # Get latest version and download tar.gz
                  cd /tmp
                  VERSION=$(curl -s https://prod.download.desktop.kiro.dev/stable/metadata-linux-x64-stable.json | jq -r .currentRelease)
                  curl -o kiro-ide.tar.gz "https://prod.download.desktop.kiro.dev/releases/stable/linux-x64/signed/$VERSION/tar/kiro-ide-$VERSION-stable-linux-x64.tar.gz"
                  
                  # Install to /opt
                  mkdir -p /opt/kiro-ide
                  tar -xzf kiro-ide.tar.gz -C /opt/kiro-ide --strip-components=1
                  rm kiro-ide.tar.gz
                  chown -R "$USERNAME:$USERNAME" /opt/kiro-ide
                  
                  # Create symlink
                  ln -sf /opt/kiro-ide/kiro /usr/local/bin/kiro-ide
                  
                  # Create desktop entry
                  cat > /usr/share/applications/kiro-ide.desktop << 'KIROEOF'
                  [Desktop Entry]
                  Version=1.0
                  Type=Application
                  Name=Kiro IDE
                  Icon=/opt/kiro-ide/resources/app/resources/linux/code.png
                  Exec=/opt/kiro-ide/kiro
                  Terminal=false
                  Categories=Development;IDE;
                  KIROEOF
                  chmod 644 /usr/share/applications/kiro-ide.desktop
                  
                  # Create desktop shortcut for user
                  mkdir -p "/home/$USERNAME/Desktop"
                  cp /usr/share/applications/kiro-ide.desktop "/home/$USERNAME/Desktop/"
                  chmod +x "/home/$USERNAME/Desktop/kiro-ide.desktop"
                  chown "$USERNAME:$USERNAME" "/home/$USERNAME/Desktop/kiro-ide.desktop"
                  
                  # Install xdg-utils and set Chrome as default browser for authentication
                  apt-get install -y xdg-utils
                  sudo -u "$USERNAME" xdg-settings set default-web-browser google-chrome.desktop || true
                  echo "export BROWSER=google-chrome" >> "/home/$USERNAME/.bashrc"

          - name: ConfigureGitAndRepo
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  USERNAME=$(cat /etc/kiro-username)
                  
                  # Configure git
                  sudo -u "$USERNAME" git config --global user.email "{{ UserEmail }}"
                  sudo -u "$USERNAME" git config --global user.name "{{ UserFullName }}"
                  
                  # Clone repository if provided and directory doesn't exist
                  if [ -n "{{ RepoUrl }}" ] && [ ! -d "{{ HomeFolder }}/project" ]; then
                    cd "{{ HomeFolder }}"
                    sudo -u "$USERNAME" git clone "{{ RepoUrl }}" project
                    chown -R "$USERNAME:$USERNAME" "{{ HomeFolder }}/project"
                  fi

          - name: FinalizeSetup
            action: aws:runShellScript
            inputs:
              runCommand:
                - |
                  # Reboot to ensure all services start properly
                  reboot

  # EC2 Instance
  Instance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !FindInMap [AmdImage, Ubuntu-24, ImageId]
      InstanceType: !Ref InstanceType
      IamInstanceProfile: !Ref InstanceProfile
      SecurityGroupIds:
        - !Ref InstanceSecurityGroup
      SubnetId: !Ref PublicSubnet
      BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            VolumeSize: !Ref InstanceVolumeSize
            VolumeType: gp3
            DeleteOnTermination: true
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          echo "Bootstrap complete - setup handled by SSM document"
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-KiroIDE-Instance'

  # CloudFront Distribution
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        DefaultCacheBehavior:
          TargetOriginId: !Sub CloudFront-${AWS::StackName}
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods: [DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT]
          CachedMethods: [GET, HEAD]
          CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad
          OriginRequestPolicyId: 216adef6-5c7f-47e4-b989-5492eafa07d3
        CacheBehaviors:
          - PathPattern: "/dcv*"
            TargetOriginId: !Sub CloudFront-${AWS::StackName}
            ViewerProtocolPolicy: redirect-to-https
            AllowedMethods: [DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT]
            CachedMethods: [GET, HEAD]
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad
            OriginRequestPolicyId: 216adef6-5c7f-47e4-b989-5492eafa07d3
        Origins:
          - DomainName: !GetAtt Instance.PublicDnsName
            Id: !Sub CloudFront-${AWS::StackName}
            CustomOriginConfig:
              OriginProtocolPolicy: https-only
              HTTPPort: 8443
              HTTPSPort: 8443

  # Custom resource to run SSM document
  RunSSMDoc:
    Type: Custom::RunSSMDoc
    Properties:
      ServiceToken: !GetAtt RunSSMDocLambda.Arn
      InstanceId: !Ref Instance
      DocumentName: !Ref KiroIDESSMDoc
      SecretArn: !Ref UserCredentials
      UserEmail: !Ref UserEmail
      UserFullName: !Ref UserFullName
      HomeFolder: !Ref HomeFolder
      RepoUrl: !Ref RepoUrl
      StackName: !Ref AWS::StackName

  RunSSMDocLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      MemorySize: 128
      Timeout: 600
      Architectures: [x86_64]
      Handler: index.lambda_handler
      Role: !GetAtt RunSSMDocLambdaRole.Arn
      Code:
        ZipFile: |
          import cfnresponse
          import boto3
          import json
          
          def lambda_handler(event, context):
              if event['RequestType'] != 'Create':
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                  return
              try:
                  props = event['ResourceProperties']
                  
                  # Retrieve password from Secrets Manager
                  secretsmanager = boto3.client('secretsmanager')
                  secret_arn = props['SecretArn']
                  secret_response = secretsmanager.get_secret_value(SecretId=secret_arn)
                  password = secret_response['SecretString']
                  
                  # Prepare parameters with resolved password
                  params = {k: [v] for k, v in props.items() 
                           if k not in ['ServiceToken', 'InstanceId', 'DocumentName', 'SecretArn']}
                  params['UserPassword'] = [password]
                  
                  response = boto3.client('ssm').send_command(
                      InstanceIds=[props['InstanceId']],
                      DocumentName=props['DocumentName'],
                      Parameters=params)
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, 
                      {'CommandId': response['Command']['CommandId'], 'Password': password})
              except Exception as e:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, str(e))

  RunSSMDocLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SSMAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action: 
                  - ssm:SendCommand
                  - secretsmanager:GetSecretValue
                Resource: '*'

  # SNS Topic for Notifications
  DeploymentNotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: Kiro IDE Deployment Notifications
      TopicName: !Sub 'KiroIDE-Notification-${AWS::StackName}'

  DeploymentNotificationSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Protocol: email
      TopicArn: !Ref DeploymentNotificationTopic
      Endpoint: !Ref UserEmail

  StackStatusRule:
    Type: AWS::Events::Rule
    Properties:
      EventPattern:
        source: ["aws.cloudformation"]
        detail-type: ["CloudFormation Stack Status Change"]
        detail:
          stack-id: [!Ref AWS::StackId]
          status-details:
            status: ["CREATE_COMPLETE", "CREATE_FAILED", "UPDATE_COMPLETE", "UPDATE_FAILED"]
      Targets:
        - Arn: !GetAtt NotificationLambda.Arn
          Id: "StackStatusTarget"

  NotificationLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.handler
      Timeout: 30
      Code:
        ZipFile: !Sub |
          import boto3
          
          sns = boto3.client('sns')
          ssm = boto3.client('ssm')
          secretsmanager = boto3.client('secretsmanager')
          
          def handler(event, context):
              try:
                  detail = event['detail']
                  status = detail['status-details']['status']
                  stack_id = detail['stack-id']
                  
                  # Get password from Secrets Manager
                  password = secretsmanager.get_secret_value(SecretId="${UserCredentials}")['SecretString']
                  
                  # Get username from SSM Parameter Store
                  param_name = "/KiroIDE/${AWS::StackName}/Username"
                  try:
                      username = ssm.get_parameter(Name=param_name)['Parameter']['Value']
                  except:
                      username = "Check /etc/kiro-username on instance"
                  
                  message = "Kiro IDE Deployment " + status + " for ${UserEmail}\n\n"
                  message += "Stack ID: " + stack_id + "\n\n"
                  message += "Access Information:\n"
                  message += "URL: https://${CloudFrontDistribution.DomainName}/dcv\n"
                  message += "Username: " + username + "\n"
                  message += "Password: " + password + "\n\n"
                  message += "Please enter the username and password when prompted to access your Kiro IDE environment."
                  
                  sns.publish(
                      TopicArn='${DeploymentNotificationTopic}',
                      Message=message,
                      Subject='Kiro IDE Deployment ' + status
                  )
                  
                  return {'statusCode': 200}
              except Exception as e:
                  print('Error: ' + str(e))
                  return {'statusCode': 500}
      Role: !GetAtt NotificationLambdaRole.Arn

  NotificationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: NotificationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: sns:Publish
                Resource: !Ref DeploymentNotificationTopic
              - Effect: Allow
                Action: secretsmanager:GetSecretValue
                Resource: !Ref UserCredentials
              - Effect: Allow
                Action: ssm:GetParameter
                Resource: !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/KiroIDE/${AWS::StackName}/Username'

  NotificationLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref NotificationLambda
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt StackStatusRule.Arn

Outputs:
  KiroIDEURL:
    Description: Kiro IDE Access URL via CloudFront
    Value: !Sub 'https://${CloudFrontDistribution.DomainName}/dcv'
  
  Password:
    Description: User Password for Kiro IDE access
    Value: !GetAtt RunSSMDoc.Password
  
  InstanceId:
    Description: EC2 Instance ID
    Value: !Ref Instance
  
  UserCredentialsSecret:
    Description: Secrets Manager secret containing user credentials
    Value: !Ref UserCredentials
  
  UserEmail:
    Description: User email address
    Value: !Ref UserEmail
